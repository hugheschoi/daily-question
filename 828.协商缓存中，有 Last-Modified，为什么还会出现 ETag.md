# Problem: 协商缓存中，有 Last-Modified，为什么还会出现 ETag?

## 自己的解答
Last-Modified 记录的是资源上次修改的时间传给客户端，客户端之后每次请求该资源，会带上 if-modified-since 把时间带上服务端，服务端会用这个if-modified-since的时间和资源的修改时间比较，如果一样，则返回304，客户端从缓存中获取，如果不一样，返回200，并将最新修改时间用 Last-Modified 传给客户端。

但是这种方式有缺陷：
1. 精确度不够，If-Modified-Since 只精确到秒
2. 一种情况，资源修改日期变化了，而实际内容没变，这种情况没能使用缓存

因此出现了 ETag 的解决方案，它是基于资源文件内容产生唯一的标识 md5，这种方式的协商会精准，比Last-Modified 的方式更佳。
具体做法，服务端计算得到文件内容唯一标识，通过 ETag 发给客户端，客户端下次用if-none-match 进行协商缓存

## chatGpt

在协商缓存中，当浏览器向服务器发起请求时，服务器会返回该资源的 Last-Modified 和 ETag 两个响应头字段。

Last-Modified 表示最后一次修改资源的时间，而 ETag 则表示资源内容的唯一标识（通常使用哈希算法对资源内容计算得出），也可以理解成资源版本号。

浏览器在进行缓存判断时，会根据请求头 If-Modified-Since 字段携带的值，与服务器返回的 Last-Modified 进行比较。如果本地缓存的资源上次修改时间早于 Last-Modified 的时间，说明该资源已经过期，需要重新从服务器获取。

但是，有些场景下资源的内容并未发生变化，但是资源的 Last-Modified 可能会被更新（比如文件上传了一个新文件、拷贝同样一个文件到另外一个存储位置等等），此时浏览器就会出现错误的返回“Not Modified”状态，导致客户端缓存不更新，性能损失。

为了解决这个问题，ETag 产生了。使用 ETag 来代替 Last-Modified 进行缓存验证，即浏览器发送 If-None-Match 请求头，服务器收到请求之后先检查客户端传来的 ETag 值是否与服务器上该资源的 ETag 值相匹配，若相匹配，说明资源没有被修改过，则返回304 Not Modified，否则将资源传递给客户端。这种方式更加精准，可以避免误判。
